from files import TXT_FILE

"""
- Контекстные менеджеры - упрощают управление ресурсами ОС.
- Контекстные менеджеры являются удобным инструментом в Python для управления ресурсами, такими как файлы, сетевые соединения и другими объектами, 
- которым требуется освобождение после использования, они упрощают код и обеспечивают лучшее управление исключениями.
-
- Оператор with в Python предназначен для облегчения работы с ресурсами, которые требуют корректного освобождения после использования.
- Файл открывается, его содержимое считывается, а затем файл закрывается. 
- Если все проходит гладко, то нет проблем. Однако, если при чтении файла возникает исключение, то закрытие файла может не произойти. 
- Это может привести к различным проблемам, таким как утечка ресурсов.
-
- Один из способов обойти эту проблему — использовать блок try/finally.
- Однако, оператор with предназначен для упрощения этого процесса и обеспечения корректного освобождения ресурсов.
"""

print("\nКонтекстный менеджер через оператор with", 20 * "=", "\n")

# Функция считывает весь файл сразу, с помощью оператора with, реализованного как синтаксический сахар.
with open(TXT_FILE, "r") as tmp_file:  # Вызов функции открытия и определение файла (передаем путь к файлу, атрибуты).
    # tmp_file будет определяться в качестве класса, к которому можно обращаться для взаимодействия.
    print(tmp_file.read())   # Выводим построчно полученные значения из итератора.
    # Нет необходимости вызывать метод закрытия close(), потому что контекстный менеджер все сделает за нас.

print("\nКонтекстный менеджер через оператор with с условием для цикла for", 20 * "=", "\n")

# Более сложный функционал через оператор with с условием для цикла for.
is_found = False  # Выполнять цикл, пока не выполнится условие.
with open(TXT_FILE, "r") as temp_file:  # определение файла temp_file (передаем путь к файлу, атрибуты).
    for line in temp_file.readlines():  # Считываем каждую строку и загружаем в память, с помощью метода readlines(), который реализован как итератор.
        print(line)  # Выводим построчно полученные значения из итератора.
        if 'же' in line:  # Если условие верное, т.е. в строке присутствует частица "же", то цикл завершается.
            is_found = True
            break  # Завершаем и выходим из цикла.


"""
- Обработчик исключений.
- Конструкция try/except/finally, которая позволяет отлавливать ошибки, в виде исключений - не стандартного поведения программы.
- Тем не менее, даже если код синтаксически написан правильно, могут возникать ошибки. 
- В Python эти ошибки называются исключения (exceptions).
-
- Для работы с исключениями используется конструкция try/except, которая работает таким образом:
- 1. Если в ходе исполнения данного блока исключений не будет, то ни один из обработчиков не задействуется.
- 2. Если в ходе исполнения инструкций в этом блоке будет зафиксировано исключение, то начнётся поиск подходящего для него обработчика. 
- Поиск производится по блокам except поочерёдно, поэтому более широкие типы исключений (базовые) имеет смысл ставить после более узких.
-
- Сначала выполняются выражения, которые записаны в блоке try.
- Если при выполнения блока try не возникло никаких исключений, блок except пропускается, и выполняется дальнейший код.
- Если во время выполнения блока try в каком-то месте возникло исключение, оставшаяся часть блока try пропускается.
- Если в блоке except указано исключение, которое возникло, выполняется код в блоке except.
- Если исключение, которое возникло, не указано в блоке except, выполнение программы прерывается и выдается ошибка.
-
- Исключение распространяется по стеку вызова, если только на его пути не встретится блок finally, возбуждающий другое исключение. 
- В этом случае прежнее исключением будет «потеряно» из-за нового.
- Блок finally - это еще один опциональный блок в конструкции try, который выполняется всегда, независимо от того, было ли исключение или нет.
- Сюда ставятся действия, которые надо выполнить в любом случае. Например, это может быть закрытие файла.
"""

print("\nОбработчик исключений", 20 * "=", "\n")

try:
    tempo_file = open(TXT_FILE, 'r')    # Определение файла temp_file (передаем путь к файлу, атрибуты).
    # print(tempo_file.read())   # Выводим полученные значения из файла.

    for line in tempo_file.readlines():  # Циклом for построчно загружаем в память, с помощью метода readlines(), который реализован как итератор.
        print(line)  # Считываем и выводим построчно полученные значения из итератора, не загружая весь файл в память.
        if 'же' in line:  # Если условие верное, т.е. в строке присутствует частица "же", то цикл завершается.
            is_found = True
            break  # Завершаем и выходим из цикла.

# Код внутри выражения try, может вызвать исключение для не стандартного поведение программы.
# Программа может получить ошибку, которую с помощью исключений можно, на верхнем уровне перехватить и обработать эту ошибку.
# Сделать сообщение об ошибке более информативным для пользователя.
# Блок except выполняется, если случилась ошибка.

except RuntimeError as err_run:  # Тип ошибки Runtime error 76 path not found - не может найти указанный путь или файл.
    print(err_run)
    print("Файл не найден, ошибка в имени файла, проверьте правильность указанного пути к папке или файлу.")
except NameError as err_name:  # Тип ошибки NameError: name is not defined - не может найти указанный файл, имя не определено.
    print(err_name)
    print("Файл не найден, проверьте правильность указанного имени или название файла.")
finally:    # Блок finally всегда выполняется в любом случае, после обоих блоков try except.
    temp_file.close()   # Завершаем и выходим из цикла.

"""
- Чтобы создать свой контекстный менеджер в Python, необходимо определить класс, который содержит методы __enter__() и __exit__().
- Контекстный менеджер в Python — это объект, который определяет методы __enter__() и __exit__() и используется с инструкцией with.
- Контекстные менеджеры позволяют автоматически выделять и освобождать ресурсы, например, открытие и закрытие файлов или соединений с базами данных. 
- Они используются вместе с оператором with, который гарантирует выполнение определенного кода перед входом в блок и после выхода из него.
- 
- Метод __enter__() выполняется перед выполнением блока кода внутри оператора with. 
- Он может выполнять какие-либо подготовительные действия или возвращать значение, которое будет связано с переменной после ключевого слова as.
-
- Метод __exit__() вызывается после завершения выполнения блока кода with. 
- Он используется для выполнения завершающих действий, таких как освобождение ресурсов, обработка исключений или выполнение финализирующих операций.
"""

print("\nОпределение класса для контекстного менеджера", 20 * "=", "\n")


class MyOpenFile:       # Определение Класса MyOpenFile.
    def __init__(self, file_name, method):      # Инициализация метода __init__.
        self.file_obj = open(file_name, method)     # Определение объекта файла file_obj (передаем путь к файлу, метод).

    def __enter__(self):      # Подготовительные действия или возвращение значения переменной после ключевого слова as.
        return self.file_obj      # Возвращаем объект файла file_obj, чтобы предоставил нужные методы для вызова.

    def __exit__(self, exc_type, exc_val, exc_tb):       # Обработка исключений и выполнения завершающих действий.
        self.file_obj.close()    # В конце завершаем работу, вызывая метод close().


# Конструкция контекстного менеджера - with/as, которая гарантирует закрытие файла в любом случае.
# Иногда это более удобная конструкция, чем try/except/finally.
# Обращение к файлу с помощью Класса, через оператор with для метода, который считывает весь файл сразу.

with MyOpenFile(TXT_FILE, "r") as my_file:    # Определение объекта файла (передаем путь к файлу, метод).
    print(my_file.read())    # Первый раз, выводим полученные значения из всего файла.

# Обработчик исключений.
my_context = MyOpenFile(TXT_FILE, "r")      # Вызов объекта my_context с присвоением Класса (передаем путь к файлу, метод).
try:
    my_file = my_context.__enter__()   # Вызов метода __enter__() внутри блока try.
    print(my_file.read())    # Второй раз, выводим полученные значения из всего файла.
finally:
    # Вызов завершающего метода __exit__() внутри блока finally.
    my_context.__exit__('exc_type', 'exc_val', 'exc_tb')

# Передаем переменные, просто случайные для примера: 'exc_type', 'exc_val', 'exc_tb'.
# Потому что они не важны и ни к чему не привязанные, от балды.
# Для примера, если нужно обернуть работу с внешней базой данных системы, какой-то коннект.
# Можно реализовать контекстный менеджер, для того чтобы не думать о закрытии программы после запуска.
