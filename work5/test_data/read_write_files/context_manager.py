from files import TXT_FILE

"""
- Контекстные менеджеры - упрощают управление ресурсами ОС.
- Контекстные менеджеры являются удобным инструментом в Python для управления ресурсами, такими как файлы, сетевые соединения и другими объектами, 
- которым требуется освобождение после использования, они упрощают код и обеспечивают лучшее управление исключениями.
-
"""

# Функция считывает весь файл сразу, с помощью оператора with, реализованного как синтаксический сахар.
with open(TXT_FILE, "r") as tmp_file:  # Вызов функции открытия и определение файла (передаем путь к файлу, атрибуты).
    print(tmp_file.read())  # tmp_file будет определяться в качестве класса, к которому можно обращаться для взаимодействия.
    # Нет необходимости вызывать метод закрытия close(), потому что контекстный менеджер все сделает за нас.

print("\n", 20 * "=", "\n")

# Более сложный функционал через оператор with с условием для цикла for.
is_found = False  # Выполнять цикл, пока не выполнится условие.
with open(TXT_FILE, "r") as temp_file:
    for line in temp_file.readlines():  # Считываем каждую строку и загружаем в память, с помощью метода readlines(), который реализован как итератор.
        print(line)  # Выводим построчно полученные значения из итератора.
        if 'же' in line:  # Если условие верное, т.е. в строке присутствует частица "же", то цикл завершается.
            is_found = True
            break  # Завершаем и выходим из цикла.

print("\n", 20 * "=", "\n")

"""
- Обработчик исключений.
- Конструкция try/except/finally, которая позволяет отлавливать ошибки, в виде исключений - не стандартного поведения программы.
- Тем не менее, даже если код синтаксически написан правильно, могут возникать ошибки. 
- В Python эти ошибки называются исключения (exceptions).
-
- Для работы с исключениями используется конструкция try/except, которая работает таким образом:
- 1. Если в ходе исполнения данного блока исключений не будет, то ни один из обработчиков не задействуется.
- 2. Если в ходе исполнения инструкций в этом блоке будет зафиксировано исключение, то начнётся поиск подходящего для него обработчика. 
- Поиск производится по блокам except поочерёдно, поэтому более широкие типы исключений (базовые) имеет смысл ставить после более узких.
-
- Сначала выполняются выражения, которые записаны в блоке try.
- Если при выполнения блока try не возникло никаких исключений, блок except пропускается, и выполняется дальнейший код.
- Если во время выполнения блока try в каком-то месте возникло исключение, оставшаяся часть блока try пропускается.
- Если в блоке except указано исключение, которое возникло, выполняется код в блоке except.
- Если исключение, которое возникло, не указано в блоке except, выполнение программы прерывается и выдается ошибка.
-
- Исключение распространяется по стеку вызова, если только на его пути не встретится блок finally, возбуждающий другое исключение. 
- В этом случае прежнее исключением будет «потеряно» из-за нового.
- Блок finally - это еще один опциональный блок в конструкции try, который выполняется всегда, независимо от того, было ли исключение или нет.
- Сюда ставятся действия, которые надо выполнить в любом случае. Например, это может быть закрытие файла.
"""

try:
    temp_file = open(TXT_FILE, 'r')
    for line in temp_file.readlines():  # Считываем каждую строку и загружаем в память, с помощью метода readlines(), который реализован как итератор.
        print(line)  # Выводим построчно полученные значения из итератора.
        if 'же' in line:  # Если условие верное, т.е. в строке присутствует частица "же", то цикл завершается.
            is_found = True
            break  # Завершаем и выходим из цикла.
    # print(file.read())      # внутри try программа может получить ошибку, можно перехватить эту ошибку и ее обработать сделать более информативной.
except RuntimeError as err_run:
    print(err_run)
    print("Файл не найден, ошибка в имени файла, проверьте правильность указанного пути к папке или файлу.")    # тип ошибки Runtime error 76 path not found - не может найти указанный путь или файл.
except NameError as err_name:
    print(err_name)
    print("Файл не найден, проверьте правильность указанного имени или название файла.")
finally:
    temp_file.close()


"""
- Чтобы создать свой контекстный менеджер в Python, необходимо определить класс, который содержит методы __enter__() и __exit__().
- Контекстный менеджер в Python — это объект, который определяет методы __enter__() и __exit__() и используется с инструкцией with.
- Контекстные менеджеры позволяют автоматически выделять и освобождать ресурсы, например, открытие и закрытие файлов или соединений с базами данных. 
- Они используются вместе с оператором with, который гарантирует выполнение определенного кода перед входом в блок и после выхода из него.
- 
- Метод __enter__() выполняется перед выполнением блока кода внутри оператора with. 
- Он может выполнять какие-либо подготовительные действия или возвращать значение, которое будет связано с переменной после ключевого слова as.
-
- Метод __exit__() вызывается после завершения выполнения блока кода with. 
- Он используется для выполнения завершающих действий, таких как освобождение ресурсов, обработка исключений или выполнение финализирующих операций.
"""

print("\n", 20 * "=", "\n")


class MyOpenFile:
    def __init__(self, file_name, method):
        self.file_obj = open(file_name, method)

    def __enter__(self):
        return self.file_obj

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file_obj.close()


with MyOpenFile(TXT_FILE, "r") as file:
    print(file.read())

my_context = MyOpenFile(TXT_FILE, "r")
try:
    file = my_context.__enter__()
    print(file.read())
finally:
    my_context.__exit__('exc_type', 'exc_val', 'exc_tb')
